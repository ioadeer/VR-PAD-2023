---
title: "Experimento tamaño de sala virtual (N=50)"
author: "Joaquin Cervino"
date: "2023-08-10"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r dependencies,  include=FALSE}
# Dependencias ------------------------------------------------------------
library(broom)
library(broom.mixed)
library(dplyr)
library(ggbeeswarm)
library(gmodels)
library(ggplot2)
library(ggthemes)
library(ggpubr)
library(ggstatsplot)
library(gridExtra)
library(htmlwidgets)
library(quickpsy)
library(tidyverse)
library(lme4)
library(nlme)
library(lmerTest)
library(modelr)
library(scales) 
library(pracma)
library(plotly)
library(Routliers)
library(processx)
library(orca)
```

# Introducción

La motivación de este experimento consiste en probar lo aseverado en Calcagno et al. que sugiere que la modalidad visual tiene una influencia en la percepeción auditiva de distancia. 

H1: El tamaño de sala afecta la percepción auditiva de distancia.

H2: El tamaño máximo de sala percibido visualmente se correlaciona positivamente con la mayor distancia reportada para la percepción auditiva de distancia.
 
# Materiales y métodos

Para probar estas hipótesis se realizó un setup experimental mixto. En este coexisten entornos virtuales visuales (mediante un casco de realidad virtual) y fuentes reales ubicadas en el mismo entorno acústico (sala del Lapso).

El uso del casco de realidad virtual consiste de una aplicación en UE 5.0 que permite situar al sujeto en entornos virtuales para realizar una manipulación experimental en la modalidad visual. Esta manipulación consiste de dos condiciones. Por un lado, una sala virtual equivalente en tamaño y aspecto a la sala real en la cual el participante realiza la tarea. Por otro lado, una sala que es la mitad en tamaño de profundidad, esto es, la pared situada en frente del participante.

En lo que respecta a la parte auditiva, se utilizó una configuración de parlantes clásicas para relevar curvas de distancia. Esta configuración consiste en situar parlantes a distintas distancias en el plano frontal del sujeto a lo largo del eje anetoro posterior. Las distancias utilizadas fueron: 2 m, 2.7 m, 3.65 m, 4.9 m, 6.65 m y 9 m. De los parlantes se emite un estimulo sonoro, un burst de ruido blanco de duración de 500 ms. El estímulo se emite con intensidad equivalente desde los distintos parlantes para inducir el cue o pista mas significativo del la percepción auditiva de distancia que es la variación de la intensidad del estímulo en función de la distancia.

Para realizar el experimento, los participantes fueron divididos en dos grupos. A cada grupo se lo exponía a un entorno virtual diferente. Un grupo veía en primer instancia en el entorno virtual una sala congruente con la sala real en la que se encontraba. El otro grupo, era expuesto a una sala de mitad del tamaño en profundidad.
Los participantes fueron introducidos en la sala experimental con los ojos vendados para que no conocieran el entorno real de forma visual. Una vez dentro de la sala experimental, se sentaban en una silla y se les colocaba el casco de realidad virtual procurando que no vieran la sala real. Con el casco ya colocado se les mostraba una sala virtual congruente o no congruente, dependiendo del grupo al que pertenecieran. Luego de exponer a los participantes al entorno virtual durante unos instantes, se apagaba el estímulo visual y debían dar un reporte verbal a ciegas de la distancia a la cual percibiían estímulos sonoros. En un segundo bloque, se les mostraba la sala que no habían visto previamente, y luego realizaban la misma tarea de reporte verbal de localización de estiímulos sonoros. 

Este diseño fue motivado para poder observar la existencia de un efecto tanto entre sujetos como intra sujetos.

# Participantes

Del experimento participaron 50 sujetos. *SACAR DATOS POBLACIONALES*
      
# Análisis de datos

```{r load_data, include=FALSE}

tabla.raw <- read.csv('./data/data-1-50-bloque-1-sin-outliers.csv', header = TRUE, sep = ' ', stringsAsFactors = TRUE)

tabla.raw$SesgoAbs <-  tabla.raw$respuesta - tabla.raw$distancia
tabla.raw$SesgoRel <- (tabla.raw$respuesta - tabla.raw$distancia) / tabla.raw$distancia


f_promedio <- function(x) c(mean = mean(x),
                            sd   = sd(x),
                            var  = var(x),
                            sem  = sd(x)/sqrt(length(x)),
                            n    = length(x))

tabla.ind <- tibble(aggregate(cbind(respuesta,SesgoRel) ~ nsub*condicion_sala*distancia*nbloque,
                              data = tabla.raw,
                              FUN  = f_promedio,na.action = NULL))

# - Nivel poblacional

tabla.pob <- tibble(aggregate(cbind(respuesta[,"mean"],SesgoRel[,"mean"]) ~ condicion_sala*distancia,
                              data <- tabla.ind,
                              FUN  <- f_promedio,na.action = NULL))


tabla.pob = tabla.pob %>% rename(respuestapob = V1)
tabla.pob = tabla.pob %>% rename(sesgorelpob = V2)


```

## Figuras

### Individual con brutos

```{r individual con brutos, echo=FALSE, message=FALSE, warning=FALSE}
g1 <- ggplot() +
  geom_line(data= tabla.ind, aes(x = distancia, y = respuesta[,"mean"], group = nsub, col=condicion_sala), alpha = 0.2)+
  geom_line(data= tabla.pob, aes(x = distancia, y = respuestapob[,"mean"], group = condicion_sala, col = condicion_sala), alpha = 1)+
  geom_errorbar(data=tabla.pob, aes(x = distancia, y = respuestapob[,"mean"], 
                                    ymin = respuestapob[,"mean"] - respuestapob[,"sem"], 
                                    ymax = respuestapob[,"mean"] + respuestapob[,"sem"],
                                    col = condicion_sala),
                alpha = 0.7, width=0.3, linewidth=0.75,
                )+
  scale_x_continuous(name="Distance source (m)")+
  scale_y_continuous(name="Perceived distance (m)")+
  geom_abline(intercept = 0, slope = 1, linetype="dashed") +
 
  theme_linedraw(base_size = 9)

plot(g1)

```

### Sesgo

```{r sesgo, echo=FALSE, message=FALSE, warning=FALSE}
## Sesgo
tabla_sesgo <- tabla.ind %>% 
  group_by(condicion_sala,nsub) %>%
  summarise(mDist_perc = mean(respuesta[,"mean"]),
            mSesgoRel  = mean(SesgoRel[,"mean"]))  %>%
  ungroup()

tabla_sesgo.pob <- tabla_sesgo  %>% 
  group_by(condicion_sala) %>%
  summarise(MSesgoRel = mean(mSesgoRel),
            N = n()) %>%
  ungroup()

fig.sesgo <- ggplot(tabla_sesgo, aes(x = condicion_sala,
                                     y = mSesgoRel,
                                     colour = condicion_sala))+
geom_point(size = 4,alpha = 1,
           position = position_jitterdodge(jitter.width = .1,
                                           jitter.height = 0,
                                           dodge.width = .1)) +
  # stat_summary(fun.data = "mean_se",
  #              geom = "bar",
  #              alpha = .4,
  #              size = 1,
  #              position = position_dodge(width = 1)) +
  stat_summary(fun.data = "mean_se",
               geom = "line") +
  stat_summary(fun.data = "mean_se",
               geom = "bar",
               alpha = .4,
               size=2,
               position = position_dodge(width = 1)) +
  labs(x = "Condition de sala",
       y = "Bias") +
  theme_pubr(base_size = 9, margin = TRUE)
# theme(legend.position = "none")
fig.sesgo

```

## Estadistica

### Modelo de efectos mixtos y anova.

```{r lmer, echo=FALSE, warning=TRUE}

m.distancia <- lmer(log(respuesta[,"mean"]) ~ condicion_sala * log(distancia) + (1|nsub), 
                    data = tabla.ind)

summary(m.distancia)
anova(m.distancia)

```
### Analisis de funcion de potencia

``` {r power function sala chica, echo=FALSE, message=FALSE, warning=FALSE}
tabla.chica.ind <- tabla.ind %>%
  filter(condicion_sala =="SALA_CHICA")

tabla.chica.pob <- tabla.pob %>%
  filter(condicion_sala == "SALA_CHICA")

tabla.chica.pob <- tabla.chica.pob %>%
  mutate(
    log_respuesta = log(respuestapob[,"mean"]),
    log_distancia = log(distancia)
  )

tabla.chica.ind <- tabla.chica.ind %>%
  mutate(
    log_respuesta = log(respuesta[,"mean"]),
    log_distancia = log(distancia)
  )

m.distancia.sala_chica <- lm(log_respuesta ~ log_distancia, 
                    data = tabla.chica.pob)


tabla.chica.pob <- tabla.chica.pob %>%
  mutate(
    predi = predict(m.distancia.sala_chica),
  )

eqn <- sprintf(
  "italic(k) == %.3g * ',' ~~ italic(a) == %.3g  * ',' ~~ italic(r)^2 ~ '=' ~ %.2g",
  coef(m.distancia.sala_chica)[1],
  coef(m.distancia.sala_chica)[2],
  summary(m.distancia.sala_chica)$r.squared
)

g1 <- ggplot() +
  #geom_line(data= tabla.ind, aes(x = log(distancia), y = respuesta[,"mean"], group = nsub, col=condicion_sala), alpha = 0.2)+
  geom_line(data= tabla.chica.pob, aes(x = log_distancia, y = predi), alpha = 0.9)+
  geom_point(data = tabla.chica.pob, mapping = aes(x=log_distancia, y=log_respuesta))+
  geom_point(data = tabla.chica.ind, mapping = aes(x=log_distancia, y=respuesta[,"mean"]), 
             color='blue', alpha=.8, shape=1, size=2.2, stroke=.2) + 
  #geom_point(data = tabla.chica.ind, mapping = aes(x=log_distancia, y=log_respuesta), 
  #           color='blue', alpha=.8, shape=1, size=2.2, stroke=.2) + 
  scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  xlab("Distancia real (log)")+
  ylab("Distancia percibida (log)") +
  ggtitle("Ajuste con funcion de potencia (log log)") +
  geom_abline(intercept = 0, slope = 1, linetype="dashed") +
  annotate("text",x = 1.1, y = 10, label= eqn, parse = TRUE) +
  theme_linedraw(base_size = 9)


g2 <- ggplot() +
  geom_line(data= tabla.chica.pob, aes(x = distancia, y = exp(predi)))+
  geom_point(data = tabla.chica.pob, mapping = aes(x=distancia, y=respuestapob[,"mean"]))+
  geom_point(data = tabla.chica.ind, mapping = aes(x=distancia, y=respuesta[,"mean"]), 
             color='blue', alpha=.8, shape=1, size=2.2, stroke=.2) + 
  scale_x_continuous(name="Distance source (m)", breaks=c(0,2,2.7,3.65,4.9,6.65,9.0), labels=c(0,2,2.7,3.65,4.9,6.65,9.0), minor_breaks=NULL) +
  scale_y_continuous(name="Perceived distance (m)",  breaks=c(0,2,2.7,3.65,4.9,6.65,9.0), labels=c(0,2,2.7,3.65,4.9,6.65,9.0), minor_breaks=NULL) +
  geom_abline(intercept = 0, slope = 1, linetype="dashed") +
  ggtitle("Sala chica ajuste con funcion de potencia") +
  annotate("text",x = 5, y = 10, label= eqn, parse = TRUE) +
  theme_linedraw(base_size = 9)

grid.arrange(g1, g2, nrow = 1)

```

``` {r power function sala grande, echo=FALSE, message=FALSE, warning=FALSE}
tabla.grande.ind <- tabla.ind %>%
  filter(condicion_sala =="SALA_GRANDE")

tabla.grande.pob <- tabla.pob %>%
  filter(condicion_sala == "SALA_GRANDE")

tabla.grande.pob <- tabla.grande.pob %>%
  mutate(
    log_respuesta = log(respuestapob[,"mean"]),
    log_distancia = log(distancia)
  )

tabla.grande.ind <- tabla.grande.ind %>%
  mutate(
    log_respuesta = log(respuesta[,"mean"]),
    log_distancia = log(distancia)
  )

m.distancia.sala_grande <- lm(log_respuesta ~ log_distancia, 
                    data = tabla.grande.pob)


tabla.grande.pob <- tabla.grande.pob %>%
  mutate(
    predi = predict(m.distancia.sala_grande),
  )

eqn <- sprintf(
  "italic(k) == %.3g * ',' ~~ italic(a) == %.3g  * ',' ~~ italic(r)^2 ~ '=' ~ %.2g",
  coef(m.distancia.sala_grande)[1],
  coef(m.distancia.sala_grande)[2],
  summary(m.distancia.sala_grande)$r.squared
)

g1 <- ggplot() +
  #geom_line(data= tabla.ind, aes(x = log(distancia), y = respuesta[,"mean"], group = nsub, col=condicion_sala), alpha = 0.2)+
  geom_line(data= tabla.grande.pob, aes(x = log_distancia, y = predi), alpha = 0.9)+
  geom_point(data = tabla.grande.pob, mapping = aes(x=log_distancia, y=log_respuesta))+
  geom_point(data = tabla.grande.ind, mapping = aes(x=log_distancia, y=respuesta[,"mean"]), 
             color='blue', alpha=.8, shape=1, size=2.2, stroke=.2) + 
  #geom_point(data = tabla.grande.ind, mapping = aes(x=log_distancia, y=log_respuesta), 
  #           color='blue', alpha=.8, shape=1, size=2.2, stroke=.2) + 
  scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  xlab("Distancia real (log)")+
  ylab("Distancia percibida (log)") +
  ggtitle("Sala grande ajuste con funcion de potencia (log log)") +
  geom_abline(intercept = 0, slope = 1, linetype="dashed") +
  annotate("text",x = 1.1, y = 10, label= eqn, parse = TRUE) +
  theme_linedraw(base_size = 9)

g2 <- ggplot() +
  geom_line(data= tabla.grande.pob, aes(x = distancia, y = exp(predi)))+
  geom_point(data = tabla.grande.pob, mapping = aes(x=distancia, y=respuestapob[,"mean"]))+
  geom_point(data = tabla.grande.ind, mapping = aes(x=distancia, y=respuesta[,"mean"]), 
             color='blue', alpha=.8, shape=1, size=2.2, stroke=.2) + 
  scale_x_continuous(name="Distance source (m)", breaks=c(0,2,2.7,3.65,4.9,6.65,9.0), labels=c(0,2,2.7,3.65,4.9,6.65,9.0), minor_breaks=NULL) +
  scale_y_continuous(name="Perceived distance (m)",  breaks=c(0,2,2.7,3.65,4.9,6.65,9.0), labels=c(0,2,2.7,3.65,4.9,6.65,9.0), minor_breaks=NULL) +
  geom_abline(intercept = 0, slope = 1, linetype="dashed") +
  ggtitle("Sala grande ajuste con funcion de potencia") +
  annotate("text",x = 5, y = 10, label= eqn, parse = TRUE) +
  theme_linedraw(base_size = 9)

grid.arrange(g1, g2, nrow = 1)

```


### Obteniendo coeficiente por sujeto

```{r many models, echo=FALSE, message=FALSE, warning=FALSE}


```





### Análisis de correlación

```{r correlación, echo=FALSE, message=FALSE, warning=FALSE}

tabla.analisis_cor <- read.csv("./data/analisis_correlacion_1_50.csv", header = TRUE, sep = ' ', stringsAsFactors = TRUE)
tabla.analisis_cor <- select(tabla.analisis_cor, c(nsub, 
                                               block_1, 
                                               SV_depth,
                                               distanca_max
                                              ))
# LOG LOG

tabla.analisis_cor <- tabla.analisis_cor %>%
  mutate(
    log_distancia_max = log(distanca_max),
    log_SV_depth = log(SV_depth)
  )

correlation_plot <- ggplot(tabla.analisis_cor, 
                              aes(x =log_SV_depth, y = log_distancia_max,
                                  colour = block_1)) +
  geom_point() +
  geom_smooth(alpha=0.3, method= "lm")+
  stat_cor(method = "pearson")+
  ggtitle("Correlacion ambas salas (log log)") +
  xlab("Profundidad de sala visual") +
  #theme(legend.title =element_blank(), legend.position = 'none')+
  ylab("Maxima distancia auditiva")

plot(correlation_plot)
```

## Sala percibida

```{r}
```

```{r sala_3d_make, echo=FALSE, message=FALSE, warning=FALSE}


dimensions.raw  <- read.csv('./data/dimensiones_de_sala_visual_1_50_sin_outliers.csv', header = TRUE, sep = ' ', stringsAsFactors = TRUE)

for (i in 1: 1:nrow(dimensions.raw)) {
  # obj = objs$shapes[[i]];
  # Sala real
  
  width = dimensions.raw$SR_width[i]
  depth = dimensions.raw$SR_depth[i]
  height = dimensions.raw$SR_height[i]
  
  if (i==1) {
    a = plot_ly(type = "mesh3d",
                scene = 'scene1',
                x = c(0, 0, depth, depth, 0, 0, depth, depth),
                y = c(0, width, width, 0, 0, width, width, 0),
                z = c(0, 0, 0, 0, height, height, height, height),
                i = c(7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2),
                j = c(3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3),
                k = c(0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6),
                opacity = 0.1,
                color = I("red"),
                intensity = 10,
                showlegend= FALSE,
                showscale = FALSE
    )
  } 
  else {
    a = add_mesh(p = a,
                 scene = 'scene1',
                 x = c(0, 0, depth, depth, 0, 0, depth, depth),
                 y = c(0, width, width, 0, 0, width, width, 0),
                 z = c(0, 0, 0, 0, height, height, height, height),
                 i = c(7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2),
                 j = c(3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3),
                 k = c(0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6),
                 opacity = 0.1,
                 color = I("red"),
                 intensity = 10,
                 showlegend= FALSE,
                 showscale = FALSE
    )
  }
  #a$scene = 'scene1'
  fig1 <- a %>% 
    hide_colorbar()
  
  # Sala grande realidad virtual
  width = dimensions.raw$SG_RV_width[i]
  depth = dimensions.raw$SG_RV_depth[i]
  height = dimensions.raw$SG_RV_height[i]
  
  if (i==1) {
   b = plot_ly(type = "mesh3d",
                scene = 'scene2',
                x = c(0, 0, depth, depth, 0, 0, depth, depth),
                y = c(0, width, width, 0, 0, width, width, 0),
                z = c(0, 0, 0, 0, height, height, height, height),
                i = c(7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2),
                j = c(3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3),
                k = c(0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6),
                opacity = 0.1,
                color = I("blue"),
                intensity = 10,
                showlegend= FALSE,
                showscale = FALSE
    )
   
  } 
  else {
    b = add_mesh(p = b,
                 scene = 'scene2',
                 x = c(0, 0, depth, depth, 0, 0, depth, depth),
                 y = c(0, width, width, 0, 0, width, width, 0),
                 z = c(0, 0, 0, 0, height, height, height, height),
                 i = c(7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2),
                 j = c(3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3),
                 k = c(0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6),
                 opacity = 0.1,
                 color = I("blue"),
                 intensity = 10,
                 showlegend= FALSE,
                 showscale = FALSE
    )
  }
  #b$scene = 'scene2'
  fig2 <- b %>% 
    hide_colorbar()
}

# https://plotly.com/r/reference/layout/
# https://plotly.com/r/reference/layout/scene/
# https://stackoverflow.com/questions/74206526/adding-a-scene-information-after-a-plot-ly-object-has-been-created
axx <- list(
  gridcolor='rgb(255, 255, 255)',
  zerolinecolor='rgb(255, 255, 255)',
  showbackground=TRUE,
  backgroundcolor='rgb(230, 230,230)'
)

fig1$x$layout$scene = 'scene1'

fig2$x$layout$scene = 'scene2'

fig <- subplot(fig1, fig2) %>% 
  layout(title = "3D Subplots", 
         # estos se tienen q llama scene y scene2 etc.
         scene = list(domain = list(x = c(0,1),y = c(0,0.5)),
                      xaxis = axx, yaxis = axx, zaxis = axx,
                      showscale = TRUE,
                      aspectmode = 'cube'),
         scene2 = list(domain = list(x = c(0,1),y = c(0.5,1)),
                       xaxis = axx, yaxis = axx, zaxis = axx,
                       showscale = FALSE,
                       aspectmode = 'cube')
         )

# fig
# fig$x$layout$showlegend = FALSE
#fig$x$layout$scene2
annotations = list( 
  list( 
    x = 0.25,  
    y = 0,  
    text = "Sala Real",  
    xref = "paper",  
    yref = "paper",  
    xanchor = "center",  
    yanchor = "bottom",  
    showarrow = FALSE 
  ),  
  list( 
    x = 0.25,  
    y = 0.5,  
    text = "Sala virtual",  
    xref = "paper",  
    yref = "paper",  
    xanchor = "center",  
    yanchor = "bottom",  
    showarrow = FALSE 
  ))

fig <- fig %>%layout(annotations = annotations) 

fig <- plotly_build(fig)
#fig
#orca(fig, "test.svg", args=c('--disable-gpu'))

# En este miniconda se instalo plotly y kaleido
reticulate::use_miniconda('r-reticulate')
#save_image(fig, "imgs/two_rooms.png", scale = 0.9, width = 500, height = 500,)

```


```{r sala_3d_render, echo=FALSE, message=FALSE, warning=FALSE}

#setwd("path/to/your/folder/with/these/bars")
#saveWidget(fig, "p1.html", selfcontained = F, libdir = "lib")
#fig
#file.show("imgs/two_rooms.png")
save_image(fig, "imgs/two_rooms.png", scale = 1.0, width = 500, height = 800)
knitr::include_graphics("imgs/two_rooms.png")
```

