---
title: "Analisis-control-limpio"
author: "Joaquin Cervino"
date: "2023-10-06"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r dependencies,  include=FALSE}
# Dependencias ------------------------------------------------------------
library(broom)
library(broom.mixed)
library(dplyr)
library(ggbeeswarm)
library(gmodels)
library(ggplot2)
library(ggthemes)
library(ggpubr)
library(ggstatsplot)
library(gridExtra)
library(htmlwidgets)
library(quickpsy)
library(tidyverse)
library(lme4)
library(nlme)
library(lmerTest)
library(modelr)
library(scales) 
library(pracma)
library(plotly)
library(Routliers)
library(processx)
library(orca)
library(hrbrthemes)
library(viridis)
```

## Intro

Este es un control sobre si hay ajuste o no entre modalidad oscuras y visual para la pad.
(escribir mas)
\pagebreak

## Analisis de datos

```{r load_data, include=FALSE}

tabla.raw <- read.csv('./data/control_sin_outliers.csv', header = TRUE, sep = ' ', stringsAsFactors = TRUE)

tabla.raw$SesgoAbs <-  abs(tabla.raw$respuesta - tabla.raw$distancia)
tabla.raw$SesgoRel <- (tabla.raw$respuesta - tabla.raw$distancia) / tabla.raw$distancia


f_promedio <- function(x) c(mean = mean(x),
                            sd   = sd(x),
                            var  = var(x),
                            sem  = sd(x)/sqrt(length(x)),
                            n    = length(x))

tabla.ind <- tibble(aggregate(cbind(respuesta,SesgoRel,SesgoAbs) ~ nsub*condicion_sala*distancia*nbloque,
                              data = tabla.raw,
                              FUN  = f_promedio,na.action = NULL))

# - Nivel poblacional

tabla.pob <- tibble(aggregate(cbind(
                              respuesta[,"mean"],
                              SesgoRel[,"mean"],
                              SesgoAbs[,"mean"]
                              ) ~ condicion_sala*distancia,
                              data <- tabla.ind,
                              FUN  <- f_promedio,na.action = NULL))


tabla.pob = tabla.pob %>% rename(respuestapob = V1)
tabla.pob = tabla.pob %>% rename(sesgorelpob = V2)


```

## Figuras

### Tabla pob

```{r individual con brutos, echo=FALSE, message=FALSE, warning=FALSE}
g1 <- ggplot() +
 geom_line(data= tabla.pob, aes(x = distancia, y = respuestapob[,"mean"], group = condicion_sala, col = condicion_sala), alpha = 1)+
 geom_errorbar(data=tabla.pob, aes(x = distancia, y = respuestapob[,"mean"],
                                   ymin = respuestapob[,"mean"] - respuestapob[,"sem"],
                                   ymax = respuestapob[,"mean"] + respuestapob[,"sem"],
                                   col = condicion_sala),
               alpha = 0.7, width=0.3, linewidth=0.75,
               )+
  scale_x_continuous(name="Distance source (m)")+
  scale_y_continuous(name="Perceived distance (m)")+
  geom_abline(intercept = 0, slope = 1, linetype="dashed") +
  theme_linedraw(base_size = 9)

plot(g1)

```

### Sesgo

```{r sesgo1, echo=FALSE, message=FALSE, warning=FALSE}
## Sesgo
tabla_sesgo <- tabla.ind %>% 
  group_by(condicion_sala,nsub) %>%
  summarise(mDist_perc = mean(respuesta[,"mean"]),
            mSesgoRel  = mean(SesgoRel[,"mean"]),
            mSesgoAbs = mean(SesgoAbs[,"mean"]))  %>%
  ungroup()

tabla_sesgo.pob <- tabla_sesgo  %>% 
  group_by(condicion_sala) %>%
  summarise(MSesgoRel = mean(mSesgoRel),
            N = n()) %>%
  ungroup()

fig.sesgo <- ggplot(tabla_sesgo, aes(x = condicion_sala,
                                     y = mSesgoRel,
                                     colour = condicion_sala))+
geom_point(size = 4,alpha = 1,
           position = position_jitterdodge(jitter.width = .1,
                                           jitter.height = 0,
                                           dodge.width = .1)) +
  stat_summary(fun.data = "mean_se",
               geom = "bar",
               alpha = .4,
               size = 1,
               position = position_dodge(width = 1)) +
  stat_summary(fun.data = "mean_se",
               geom = "line") +
  stat_summary(fun.data = "mean_se",
               geom = "bar",
               alpha = .4,
               size=2,
               position = position_dodge(width = 1)) +
  labs(x = "Condition de sala",
       y = "Bias") +
  theme_pubr(base_size = 9, margin = TRUE)
# theme(legend.position = "none")
fig.sesgo

```

```{r sesgo2, echo=FALSE, message=FALSE, warning=FALSE}

tabla_sesgo %>%
  ggplot( aes(x=condicion_sala, y=mDist_perc, fill=condicion_sala)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6) +
    geom_jitter(color="black", size=0.4, alpha=0.9) +
   # theme_ipsum() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    ggtitle("Media de distancia percibida") +
    xlab("")
```

```{r sesgo3, echo=FALSE, message=FALSE, warning=FALSE}

tabla_sesgo %>%
  ggplot( aes(x=condicion_sala, y=mSesgoRel, fill=condicion_sala)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6) +
    geom_jitter(color="black", size=0.4, alpha=0.9) +
    #theme_ipsum() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    ggtitle("Sesgo Rel") +
    xlab("")
```

```{r sesgo4, echo=FALSE, message=FALSE, warning=FALSE}

tabla_sesgo %>%
  ggplot( aes(x=condicion_sala, y=mSesgoAbs, fill=condicion_sala)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6) +
    geom_jitter(color="black", size=0.4, alpha=0.9) +
 #   theme_ipsum() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    ggtitle("Sesgo Absoluto") +
    xlab("")
```

\pagebreak

## Estadistica

### Modelo de efectos mixtos y anova.

```{r lmer, echo=FALSE, warning=TRUE}

m.distancia <- lmer(log(respuesta[,"mean"]) ~ condicion_sala * log(distancia) + (1|nsub), 
                    data = tabla.ind)

summary(m.distancia)
anova(m.distancia)

```

### Analisis de funcion de potencia

```{r power function sala oscuras, echo=FALSE, message=FALSE, warning=FALSE}
tabla.oscuras.ind <- tabla.ind %>%
  filter(condicion_sala =="OSCURAS")

tabla.oscuras.pob <- tabla.pob %>%
  filter(condicion_sala == "OSCURAS")

tabla.oscuras.pob <- tabla.oscuras.pob %>%
  mutate(
    log_respuesta = log(respuestapob[,"mean"]),
    log_distancia = log(distancia)
  )

tabla.oscuras.ind <- tabla.oscuras.ind %>%
  mutate(
    log_respuesta = log(respuesta[,"mean"]),
    log_distancia = log(distancia)
  )

m.distancia.oscuras <- lm(log_respuesta ~ log_distancia, 
                    data = tabla.oscuras.pob)


tabla.oscuras.pob <- tabla.oscuras.pob %>%
  mutate(
    predi = predict(m.distancia.oscuras),
  )

eqn <- sprintf(
  "italic(k) == %.3g * ',' ~~ italic(a) == %.3g  * ',' ~~ italic(r)^2 ~ '=' ~ %.2g",
  coef(m.distancia.oscuras)[1],
  coef(m.distancia.oscuras)[2],
  summary(m.distancia.oscuras)$r.squared
)

g1 <- ggplot() +
  #geom_line(data= tabla.ind, aes(x = log(distancia), y = respuesta[,"mean"], group = nsub, col=condicion_sala), alpha = 0.2)+
  geom_line(data= tabla.oscuras.pob, aes(x = log_distancia, y = predi), alpha = 0.9)+
  geom_point(data = tabla.oscuras.pob, mapping = aes(x=log_distancia, y=log_respuesta))+
  geom_point(data = tabla.oscuras.ind, mapping = aes(x=log_distancia, y=respuesta[,"mean"]), 
             color='blue', alpha=.8, shape=1, size=2.2, stroke=.2) + 
  #geom_point(data = tabla.oscuras.ind, mapping = aes(x=log_distancia, y=log_respuesta), 
  #           color='blue', alpha=.8, shape=1, size=2.2, stroke=.2) + 
  scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  xlab("Distancia real (log)")+
  ylab("Distancia percibida (log)") +
  ggtitle("Ajuste con funcion de potencia (log log)") +
  geom_abline(intercept = 0, slope = 1, linetype="dashed") +
  annotate("text",x = 1.1, y = 10, label= eqn, parse = TRUE) +
  theme_linedraw(base_size = 9)


g2 <- ggplot() +
  geom_line(data= tabla.oscuras.pob, aes(x = distancia, y = exp(predi)))+
  geom_point(data = tabla.oscuras.pob, mapping = aes(x=distancia, y=respuestapob[,"mean"]))+
  geom_point(data = tabla.oscuras.ind, mapping = aes(x=distancia, y=respuesta[,"mean"]), 
             color='blue', alpha=.8, shape=1, size=2.2, stroke=.2) + 
  scale_x_continuous(name="Distance source (m)", breaks=c(0,2,2.7,3.65,4.9,6.65,9.0), labels=c(0,2,2.7,3.65,4.9,6.65,9.0), minor_breaks=NULL) +
  scale_y_continuous(name="Perceived distance (m)",  breaks=c(0,2,2.7,3.65,4.9,6.65,9.0), labels=c(0,2,2.7,3.65,4.9,6.65,9.0), minor_breaks=NULL) +
  geom_abline(intercept = 0, slope = 1, linetype="dashed") +
  ggtitle("Sala oscuras ajuste con funcion de potencia") +
  annotate("text",x = 5, y = 10, label= eqn, parse = TRUE) +
  theme_linedraw(base_size = 9)

grid.arrange(g1, g2, nrow = 1)

```

```{r power function visual, echo=FALSE, message=FALSE, warning=FALSE}
tabla.visual.ind <- tabla.ind %>%
  filter(condicion_sala =="VISUAL")

tabla.visual.pob <- tabla.pob %>%
  filter(condicion_sala == "VISUAL")

tabla.visual.pob <- tabla.visual.pob %>%
  mutate(
    log_respuesta = log(respuestapob[,"mean"]),
    log_distancia = log(distancia)
  )

tabla.visual.ind <- tabla.visual.ind %>%
  mutate(
    log_respuesta = log(respuesta[,"mean"]),
    log_distancia = log(distancia)
  )

m.distancia.sala_visual <- lm(log_respuesta ~ log_distancia, 
                    data = tabla.visual.pob)


tabla.visual.pob <- tabla.visual.pob %>%
  mutate(
    predi = predict(m.distancia.sala_visual),
  )

eqn <- sprintf(
  "italic(k) == %.3g * ',' ~~ italic(a) == %.3g  * ',' ~~ italic(r)^2 ~ '=' ~ %.2g",
  coef(m.distancia.sala_visual)[1],
  coef(m.distancia.sala_visual)[2],
  summary(m.distancia.sala_visual)$r.squared
)

g1 <- ggplot() +
  #geom_line(data= tabla.ind, aes(x = log(distancia), y = respuesta[,"mean"], group = nsub, col=condicion_sala), alpha = 0.2)+
  geom_line(data= tabla.visual.pob, aes(x = log_distancia, y = predi), alpha = 0.9)+
  geom_point(data = tabla.visual.pob, mapping = aes(x=log_distancia, y=log_respuesta))+
  geom_point(data = tabla.visual.ind, mapping = aes(x=log_distancia, y=respuesta[,"mean"]), 
             color='blue', alpha=.8, shape=1, size=2.2, stroke=.2) + 
  #geom_point(data = tabla.visual.ind, mapping = aes(x=log_distancia, y=log_respuesta), 
  #           color='blue', alpha=.8, shape=1, size=2.2, stroke=.2) + 
  scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  xlab("Distancia real (log)")+
  ylab("Distancia percibida (log)") +
  ggtitle("Visual ajuste con funcion de potencia (log log)") +
  geom_abline(intercept = 0, slope = 1, linetype="dashed") +
  annotate("text",x = 1.1, y = 10, label= eqn, parse = TRUE) +
  theme_linedraw(base_size = 9)

g2 <- ggplot() +
  geom_line(data= tabla.visual.pob, aes(x = distancia, y = exp(predi)))+
  geom_point(data = tabla.visual.pob, mapping = aes(x=distancia, y=respuestapob[,"mean"]))+
  geom_point(data = tabla.visual.ind, mapping = aes(x=distancia, y=respuesta[,"mean"]), 
             color='blue', alpha=.8, shape=1, size=2.2, stroke=.2) + 
  scale_x_continuous(name="Distance source (m)", breaks=c(0,2,2.7,3.65,4.9,6.65,9.0), labels=c(0,2,2.7,3.65,4.9,6.65,9.0), minor_breaks=NULL) +
  scale_y_continuous(name="Perceived distance (m)",  breaks=c(0,2,2.7,3.65,4.9,6.65,9.0), labels=c(0,2,2.7,3.65,4.9,6.65,9.0), minor_breaks=NULL) +
  geom_abline(intercept = 0, slope = 1, linetype="dashed") +
  ggtitle("Visual ajuste con funcion de potencia") +
  annotate("text",x = 5, y = 10, label= eqn, parse = TRUE) +
  theme_linedraw(base_size = 9)

grid.arrange(g1, g2, nrow = 1)

```


### Obteniendo coeficiente por sujeto

```{r load data many models, echo=FALSE, message=FALSE, warning=FALSE}
data.clean <-  read.csv('data/coeficientes_por_sujeto.csv', header = TRUE, sep = ' ', stringsAsFactors = TRUE)

# Asi se preparo data
# modelo_sujeto  <- function(df) {
#   lmer(log_respuesta ~ log_distancia + (1|nsub) , data = df)
# }
# 
# modelo_sujeto  <- function(df) {
#   lm(log_respuesta ~ log_distancia, data = df)
# }
# 
# regressions <- tabla.ind %>%
#   nest(data = -nsub) %>%
#   mutate(
#     fit = map(data,modelo_sujeto),
#     tidied = map(fit, tidy),
#     glanced = map(fit, glance),
#     augmented = map(fit, augment)
#   )
# 
# tidied <- regressions %>%
#   unnest(tidied)
# 
# regressions %>%
#   unnest(glanced)
# 
# regressions %>%
#   unnest(augmented)
# 
# #
# # CORRECCION Guardarse el R^2 tambien
# 
# r_sqrd <- regressions %>%
#   unnest(glanced) %>%
#   group_by(nsub) %>%
#   select(nsub, r.squared)
# 
# #
# coefs <- regressions %>%
#   unnest(tidied) %>%
#   group_by(nsub) %>%
#   spread(term,estimate) %>%
#   select(nsub,"(Intercept)", log_distancia) %>%
#   rename(intercept = "(Intercept)") %>%
#   group_by(nsub) %>%
#   summarise(
#     intercept = max(intercept, na.rm =T),
#     coef = max(log_distancia, na.rm =T),
#   )
# 
# cond <- data.frame(tabla.ind$nsub, tabla.ind$condicion_sala)
# 
# cond <- cond %>%
#   rename(nsub = tabla.ind.nsub) %>%
#   rename(condicion_sala = tabla.ind.condicion_sala)
# 
# cond <- cond %>%
#   group_by(nsub)  %>%
#   distinct()
# 
# coefs <- merge(x=coefs, y=cond, by='nsub')
# 
# coefs <- merge(x=coefs, y=r_sqrd, by='nsub')
# 
# write.table(coefs, file="analisis-pad-2-salas-vacias/data/coeficientes_por_sujeto.csv", row.names = FALSE)

```